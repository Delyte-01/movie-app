// Updated FilterSidebar UI to include genre, movie type, and country filters

"use client";

import { useMovieContext } from "@/hooks/use-context";
import { useEffect, useState } from "react";

export function FilterSidebar() {
  const {
    genres,
    setMovies,
    setIsLoading,
    popular,
    fetchFilteredMoviesFromContext,
    movieTypes,
    countries,
    selectedGenre,
    setSelectedGenre,
    movieType,
    setMovieType,
    originCountry,
    setOriginCountry,
  } = useMovieContext();

  const [releaseYear, setReleaseYear] = useState("");
  const [rating, setRating] = useState(0);
  const [sortBy, setSortBy] = useState("popularity.desc");
  const [showAll, setShowAll] = useState(true);

  const handleShowAll = () => {
    setSelectedGenre("");
    setReleaseYear("");
    setRating(0);
    setSortBy("popularity.desc");
    setMovieType("");
    setOriginCountry("");
    setShowAll(true);
    setMovies(popular);
  };

  useEffect(() => {
    if (showAll) return;

    const filters = {
      with_genres: selectedGenre || undefined,
      primary_release_year: releaseYear || undefined,
      vote_average_gte: rating ? rating.toString() : undefined,
      sort_by: sortBy,
      with_type: movieType || undefined,
      with_origin_country: originCountry || undefined,
    };

    fetchFilteredMoviesFromContext(filters);
  }, [selectedGenre, releaseYear, rating, sortBy, movieType, originCountry]);

  return (
    <div className="space-y-6 text-sm">
      {/* Show All */}
      <div>
        <label className="flex items-center gap-2 cursor-pointer">
          <input
            type="checkbox"
            checked={showAll}
            onChange={handleShowAll}
            className="accent-blue-600"
          />
          <span>All</span>
        </label>
      </div>

      {/* Genres */}
      <div>
        <h3 className="font-semibold mb-2 text-gray-800">Genres</h3>
        <div className="grid grid-cols-2 gap-2">
          {genres.map((genre) => (
            <label key={genre.id} className="flex items-center gap-2 cursor-pointer">
              <input
                type="radio"
                name="genre"
                checked={selectedGenre === genre.id.toString()}
                onChange={() => {
                  setSelectedGenre(genre.id.toString());
                  setShowAll(false);
                }}
                className="accent-blue-600"
              />
              <span>{genre.name}</span>
            </label>
          ))}
        </div>
      </div>

      {/* Movie Type */}
      <div>
        <h3 className="font-semibold mb-2 text-gray-800">Type</h3>
        <select
          value={movieType}
          onChange={(e) => {
            setMovieType(e.target.value);
            setShowAll(false);
          }}
          className="w-full p-2 border rounded-md"
        >
          <option value="">All Types</option>
          {movieTypes.map((type) => (
            <option key={type} value={type}>
              {type.charAt(0).toUpperCase() + type.slice(1)}
            </option>
          ))}
        </select>
      </div>

      {/* Origin Country */}
      <div>
        <h3 className="font-semibold mb-2 text-gray-800">Country</h3>
        <select
          value={originCountry}
          onChange={(e) => {
            setOriginCountry(e.target.value);
            setShowAll(false);
          }}
          className="w-full p-2 border rounded-md"
        >
          <option value="">All Countries</option>
          {countries.map((country) => (
            <option key={country.code} value={country.code}>
              {country.name}
            </option>
          ))}
        </select>
      </div>

      {/* Release Year */}
      <div>
        <h3 className="font-semibold mb-2 text-gray-800">Release Year</h3>
        <input
          type="number"
          placeholder="e.g., 2024"
          value={releaseYear}
          onChange={(e) => {
            setReleaseYear(e.target.value);
            setShowAll(false);
          }}
          className="w-full p-2 border rounded-md"
        />
      </div>

      {/* Minimum Rating */}
      <div>
        <h3 className="font-semibold mb-2 text-gray-800">Minimum Rating</h3>
        <input
          type="range"
          min="0"
          max="10"
          value={rating}
          onChange={(e) => {
            setRating(Number(e.target.value));
            setShowAll(false);
          }}
          className="w-full"
        />
        <span className="text-sm text-gray-600">Min: {rating}</span>
      </div>

      {/* Sort By */}
      <div>
        <h3 className="font-semibold mb-2 text-gray-800">Sort By</h3>
        <select
          value={sortBy}
          onChange={(e) => {
            setSortBy(e.target.value);
            setShowAll(false);
          }}
          className="w-full p-2 border rounded-md"
        >
          <option value="popularity.desc">Popularity</option>
          <option value="vote_average.desc">Top Rated</option>
          <option value="primary_release_date.desc">Release Date</option>
        </select>
      </div>
    </div>
  );
}







// Updated MovieContext with full TV/movie filtering and release year/date handling

"use client";

import {
  fetchGenres,
  fetchNowPlayingMovies,
  fetchPopularMovies,
  fetchTopRatedMovies,
  fetchUpcomingMovies,
} from "@/lib/fetchmovies";
import { Movie } from "@/lib/types";
import {
  createContext,
  useContext,
  useEffect,
  useState,
  ReactNode,
} from "react";

interface MovieContextType {
  topRated: Movie[];
  popular: Movie[];
  upcoming: Movie[];
  nowPlaying: Movie[];
  loading: boolean;
  movies: Movie[];
  setMovies: (movies: Movie[]) => void;
  isLoading: boolean;
  setIsLoading: (loading: boolean) => void;
  genres: { id: number; name: string }[];
  movieTypes: string[];
  countries: { code: string; name: string }[];
  selectedGenre: string;
  setSelectedGenre: (genre: string) => void;
  movieType: string;
  setMovieType: (type: string) => void;
  originCountry: string;
  setOriginCountry: (country: string) => void;
  fetchFilteredMoviesFromContext: (filters: {
    with_genres?: string;
    primary_release_year?: string;
    first_air_date_year?: string;
    vote_average_gte?: string;
    sort_by?: string;
    with_origin_country?: string;
    page?: string;
  }) => void;
  loadMoreMovies: () => void;
}

const MovieContext = createContext<MovieContextType>({
  topRated: [],
  popular: [],
  upcoming: [],
  nowPlaying: [],
  loading: true,
  movies: [],
  setMovies: () => {},
  isLoading: false,
  setIsLoading: () => {},
  genres: [],
  movieTypes: ["movie", "tv"],
  countries: [],
  selectedGenre: "",
  setSelectedGenre: () => {},
  movieType: "movie",
  setMovieType: () => {},
  originCountry: "",
  setOriginCountry: () => {},
  fetchFilteredMoviesFromContext: () => {},
  loadMoreMovies: () => {},
});

export const MovieProvider = ({ children }: { children: ReactNode }) => {
  const [topRated, setTopRated] = useState<Movie[]>([]);
  const [popular, setPopular] = useState<Movie[]>([]);
  const [upcoming, setUpcoming] = useState<Movie[]>([]);
  const [nowPlaying, setNowPlaying] = useState<Movie[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [movies, setMovies] = useState<Movie[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [genres, setGenres] = useState<{ id: number; name: string }[]>([]);
  const [movieTypes] = useState<string[]>(["movie", "tv"]);
  const [countries] = useState<{ code: string; name: string }[]>([
    { code: "US", name: "USA" },
    { code: "IN", name: "India" },
    { code: "JP", name: "Japan" },
    { code: "KR", name: "South Korea" },
    { code: "NG", name: "Nigeria" },
  ]);
  const [selectedGenre, setSelectedGenre] = useState<string>("");
  const [movieType, setMovieType] = useState<string>("movie");
  const [originCountry, setOriginCountry] = useState<string>("");
  const [currentPage, setCurrentPage] = useState<number>(1);

  useEffect(() => {
    const fetchAll = async () => {
      try {
        const [top, pop, up, now, genre] = await Promise.all([
          fetchTopRatedMovies(),
          fetchPopularMovies(),
          fetchUpcomingMovies(),
          fetchNowPlayingMovies(),
          fetchGenres(),
        ]);

        setTopRated(top.results);
        setPopular(pop.results);
        setUpcoming(up.results);
        setNowPlaying(now.results);
        setGenres(genre.genres);
        setMovies(pop.results);
      } catch (error) {
        console.error("Error fetching movies:", error);
      } finally {
        setLoading(false);
      }
    };
    fetchAll();
  }, []);

  const fetchFilteredMoviesFromContext = async (filters: {
    with_genres?: string;
    primary_release_year?: string;
    first_air_date_year?: string;
    vote_average_gte?: string;
    sort_by?: string;
    with_origin_country?: string;
    page?: string;
  }) => {
    const TMDB_API_KEY = process.env.NEXT_PUBLIC_TMDB_API_KEY;
    if (!TMDB_API_KEY) return;

    setIsLoading(true);

    try {
      const params = new URLSearchParams({
        api_key: TMDB_API_KEY,
        sort_by: filters.sort_by || "popularity.desc",
        page: filters.page || "1",
      });

      if (filters.with_genres) params.append("with_genres", filters.with_genres);
      if (filters.vote_average_gte)
        params.append("vote_average.gte", filters.vote_average_gte);
      if (filters.with_origin_country)
        params.append("with_origin_country", filters.with_origin_country);

      if (movieType === "movie" && filters.primary_release_year)
        params.append("primary_release_year", filters.primary_release_year);

      if (movieType === "tv" && filters.first_air_date_year)
        params.append("first_air_date_year", filters.first_air_date_year);

      const res = await fetch(`https://api.themoviedb.org/3/discover/${movieType}?${params.toString()}`);
      const data = await res.json();

      if (Array.isArray(data.results)) {
        const tagged = data.results.map((item: any) => ({ ...item, media_type: movieType }));
        setMovies(tagged);
        setCurrentPage(parseInt(filters.page || "1"));
      }
    } catch (error) {
      console.error("Failed to fetch filtered movies", error);
    } finally {
      setIsLoading(false);
    }
  };

  const loadMoreMovies = () => {
    fetchFilteredMoviesFromContext({
      with_genres: selectedGenre || undefined,
      with_origin_country: originCountry || undefined,
      page: (currentPage + 1).toString(),
    });
  };

  return (
    <MovieContext.Provider
      value={{
        topRated,
        popular,
        upcoming,
        nowPlaying,
        loading,
        movies,
        setMovies,
        isLoading,
        setIsLoading,
        genres,
        movieTypes,
        countries,
        selectedGenre,
        setSelectedGenre,
        movieType,
        setMovieType,
        originCountry,
        setOriginCountry,
        fetchFilteredMoviesFromContext,
        loadMoreMovies,
      }}
    >
      {children}
    </MovieContext.Provider>
  );
};

export const useMovieContext = () => useContext(MovieContext);



































// Updated FilterSidebar with fetch logic moved to context and single genre selection

"use client";

import { useMovieContext } from "@/hooks/use-context";
import { useEffect, useState } from "react";

export function FilterSidebar() {
  const {
    genres,
    setMovies,

    popular,
    fetchFilteredMoviesFromContext,
  } = useMovieContext();

  const [selectedGenre, setSelectedGenre] = useState<number | null>(null);
  const [releaseYear, setReleaseYear] = useState("");
  const [rating, setRating] = useState(0);
  const [sortBy, setSortBy] = useState("popularity.desc");
  const [showAll, setShowAll] = useState(true);

  const handleGenreSelect = (id: number) => {
    setSelectedGenre((prev) => (prev === id ? null : id));
    setShowAll(false);
  };

  const handleShowAll = () => {
    setSelectedGenre(null);
    setReleaseYear("");
    setRating(0);
    setSortBy("popularity.desc");
    setShowAll(true);
    setMovies(popular);
  };

  useEffect(() => {
    if (showAll) return;

    const filters = {
      with_genres: selectedGenre ? selectedGenre.toString() : undefined,
      primary_release_year: releaseYear || undefined,
      vote_average_gte: rating ? rating.toString() : undefined,
      sort_by: sortBy,
    };

    fetchFilteredMoviesFromContext(filters);
  }, [selectedGenre, releaseYear, rating, sortBy]);

  return (
    <div className="space-y-6 text-sm">
      {/* Genres */}
      <div>
        <h3 className="font-semibold mb-2 text-gray-800">Genres</h3>
        <div className="grid grid-cols-2 gap-2">
          <label className="flex items-center gap-2 cursor-pointer">
            <input
              type="checkbox"
              checked={showAll}
              onChange={handleShowAll}
              className="accent-blue-600"
            />
            <span>All</span>
          </label>

          {genres.map((genre) => (
            <label
              key={genre.id}
              className="flex items-center gap-2 cursor-pointer"
            >
              <input
                type="radio"
                name="genre"
                checked={selectedGenre === genre.id}
                onChange={() => handleGenreSelect(genre.id)}
                className="accent-blue-600"
              />
              <span>{genre.name}</span>
            </label>
          ))}
        </div>
      </div>

      {/* Release Year */}
      <div>
        <h3 className="font-semibold mb-2 text-gray-800">Release Year</h3>
        <input
          type="number"
          placeholder="e.g., 2024"
          value={releaseYear}
          onChange={(e) => {
            setReleaseYear(e.target.value);
            setShowAll(false);
          }}
          className="w-full p-2 border rounded-md"
        />
      </div>

      {/* Minimum Rating */}
      <div>
        <h3 className="font-semibold mb-2 text-gray-800">Minimum Rating</h3>
        <input
          type="range"
          min="0"
          max="10"
          value={rating}
          onChange={(e) => {
            setRating(Number(e.target.value));
            setShowAll(false);
          }}
          className="w-full"
        />
        <span className="text-sm text-gray-600">Min: {rating}</span>
      </div>

      {/* Sort By */}
      <div>
        <h3 className="font-semibold mb-2 text-gray-800">Sort By</h3>
        <select
          value={sortBy}
          onChange={(e) => {
            setSortBy(e.target.value);
            setShowAll(false);
          }}
          className="w-full p-2 border rounded-md"
        >
          <option value="popularity.desc">Popularity</option>
          <option value="vote_average.desc">Top Rated</option>
          <option value="primary_release_date.desc">Release Date</option>
        </select>
      </div>
    </div>
  );
}
